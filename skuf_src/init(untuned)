#!/usr/bin/bash

skuf_version="4.8+37.3"

display_version() {
    local letter1="$(( RANDOM % 7 ))"
    local letter2="$(( RANDOM % 7 ))"
    local letter3="$(( RANDOM % 7 ))"
    local letter4="$(( RANDOM % 7 ))"

    echo -e "\e[1;3${letter1}mS\e[0m\e[1;3${letter2}mK\e[0m\e[1;3${letter3}mU\e[0m\e[1;3${letter4}mF\e[0m v${skuf_version}"
}

plymouth_show_msg() {
    command -v plymouth >/dev/null 2>&1 || return 0
    if plymouth --ping; then
        plymouth display-message --text="$*"
    fi

    if [ -z "$PLY_NOSAVE" ]; then
        _ply_last_msg="$*"
    else
        _ply_last_msg=""
    fi
}

plymouth_pause() {
    command -v plymouth >/dev/null 2>&1 || return 0
    if plymouth --ping; then
        plymouth report-error
        plymouth hide-splash
        plymouth deactivate
    fi
}

plymouth_continue() {
    command -v plymouth >/dev/null 2>&1 || return 0
    if plymouth --ping; then
        plymouth reactivate
        plymouth show-splash
        plymouth display-message --text="$_ply_last_msg"
    fi
}

asshole_parse() {
    while read -r line; do
        _sambaopts="$(echo "$line" | grep -o 'fuckmyass=.*:')"
        if [ -n "$sambaopts" ]; then
            msg "Found mount options in cmdline"
            break
        else
            continue
        fi
    done

    if [ -z "$_sambaopts" ]; then
        echo "Something went wrong. Failed to fetch mount options with cmdline."
        echo "Write options yourself to /_sambaopts in following format:"
        echo "IP,,,port,,,SAMBA version,,,domain,,,username,,,password,,,volume dir,,,volume file,,,swap file,,,samba mount opts,,,volume mount opts,,,fsck volume or not"
        echo "use @n@ for nothing"
        launch_interactive_shell
        _sambaopts="fuckmyass=$(cat /_sambaopts):"
    else
        _sambaopts="${_sambaopts/fuckmyass=/}"
        _sambaopts="${_sambaopts//:/}"
        _sambaopts="${_sambaopts//%/=}"

        # SKUF_DEC_TUNE #

        _sambaopts="U2FsdGVkX1${_sambaopts}"

        # SKUF_OPENSSL_DEC #
        if _sambaopts="$(echo "$_sambaopts" | openssl enc -d -aes-256-cbc -salt -iter 1234 -base64 -A -k '12345678' -in - -out -)"; then # SKUF_OPENSSL_DEC_RM #
            _sambaopts="fuckmyass=${_sambaopts}:"
        else
            echo "Failed to decrypt options!"
            echo "Write options yourself to /_sambaopts in following format:"
            echo "IP,,,port,,,SAMBA version,,,domain,,,username,,,password,,,volume dir,,,volume file,,,swap file,,,samba mount opts,,,volume mount opts,,,fsck volume or not"
            echo "use @n@ for nothing"
            launch_interactive_shell
            _sambaopts="fuckmyass=$(cat /_sambaopts):"
        fi

    fi

    sambaopts="${_sambaopts#*=}"

    smbaddr="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbport="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbversion="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbdomain="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbusername="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbpassword="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbvolumepath="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbvolumefilename="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbswapfilename="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    smbmountopts="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    newrootmountopts="${sambaopts%%,,,*}"
        sambaopts="${sambaopts#*,,,}" # cut
    newrootfsck="${sambaopts%%:*}"
        #sambaopts="${sambaopts#*,,,}" # cut
        sambaopts="${sambaopts#*:}" # cut

    smbmode="rw"
}

bring_lo_up() {
    ip link set lo up
}

get_dhcp() {
    local i interface x="0"

    for i in /sys/class/net/*; do
        interface="${i##*/}"

        case "$interface" in
            "")   continue ;;
            eth*) : ;;
            en*)  : ;;
            *)    continue ;;
        esac

        interface_list="$interface_list $interface"
        x=$(( x + 1 ))
    done

    if [ $x -eq 0 ]; then
        echo "Error: no wired network interface found. Good luck."
        # shellcheck disable=SC2086
        run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
        launch_interactive_shell --exec
    fi

    if ! dhcpcd -q --allowinterfaces 'eth* en*'; then
        # We should try again (for buggy IPv6 RA)
        echo "-> dhcpcd failed. Trying again..."
        sleep 3
        sed -i 's/^# ipv6ra_fork #$/ipv6ra_fork/' /etc/dhcpcd.conf
        if ! dhcpcd -q --allowinterfaces 'eth* en*'; then
            sed -i 's/^ipv6ra_fork$/# ipv6ra_fork #/' /etc/dhcpcd.conf
            echo "Failed to acquire DHCP address."
            launch_interactive_shell
        fi
    fi

    msg "-> IP address received. Sleeping 5 seconds..."
    sleep 5
}

renice_dhcpcd() {
    local pid pids

    renice -15 -u dhcpcd >/dev/null

    pids="$(pidof dhcpcd 2>/dev/null)" || pids="$(pgrep dhcpcd)"
    for pid in $pids; do
        renice -15 -p "$pid" >/dev/null
    done
}

mount_samba() {
    finalusername="username=$smbusername,"
    [ "$smbdomain" == "@n@" ] || finaldomain="domain=$smbdomain,"
    [ "$smbport" == "@n@" ] || finalport="port=$smbport,"
    [ "$smbmountopts" == "@n@" ] || finalmountopts="$smbmountopts,"
    smbvolumepath="${smbvolumepath/@u@/${smbusername/@*/}}"
    smbvolumepath="${smbvolumepath/@fu@/${smbusername}}"
    case "$smbvolumepath" in
        "/") : ;;
        "/"*"/") : ;;
        "/"*) smbvolumepath="${smbvolumepath}/" ;;
        *"/") smbvolumepath="/${smbvolumepath}" ;;
        "@n@") smbvolumepath="/" ;;
        *) smbvolumepath="/${smbvolumepath}/" ;;
    esac
    smbvolumefilename="${smbvolumefilename/@u@/${smbusername/@*/}}"
    smbvolumefilename="${smbvolumefilename/@fu@/${smbusername}}"
    case "$smbvolumefilename" in
        "/"*) smbvolumefilename="${smbvolumefilename#/}" ;;
    esac
    [ "$smbversion" == "@n@" ] || finalversion="vers=$smbversion,"

    if ! PASSWD="$smbpassword" mount -t cifs -o "${finalusername}${finaldomain}${finalport}${finalmountopts}${finalversion}${smbmode}" "//${smbaddr}${smbvolumepath}" /samba; then
        echo "Failed to mount SAMBA share!"
        echo "PASSWD=$smbpassword mount -t cifs -o ${finalusername}${finaldomain}${finalport}${finalmountopts}${finalversion}${smbmode} //${smbaddr}${smbvolumepath} /samba"
        launch_interactive_shell
    fi
}

fsck_in_samba() {
    # We shouldn't do it in R/O mode...
    case "$newrootfsck" in
    Yes|yes|Y|y)
    if [ "$(blkid -o value -s TYPE /samba/"${smbvolumefilename}")" == "btrfs" ]; then
        btrfsck /samba/"${smbvolumefilename}" || launch_interactive_shell
    else
        fsck -T -a -C /samba/"${smbvolumefilename}"
        fsckreturn="$?"

        if [ -n "$fsckreturn" ] && [ "$fsckreturn" -ne 255 ]; then

        if bitfield_has_bit "$fsckreturn" 4; then
            echo "fsck failed..."
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 2; then
            echo "fsck tells you need to reboot"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 8; then
            echo "Something went wrong while fsck..."
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 16; then
            echo "Syntax error in fsck"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 32; then
            echo "Somehow you canceled fsck"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 128; then
            echo "fsck FATAL ERROR xD"
            launch_interactive_shell
        fi

        fi
    fi
    ;;
    No|no|N|n)
        :
    ;;
    "@n@")
        :
    ;;
    esac
}

mount_newroot() {
    if [ "$newrootmountopts" == "@n@" ]; then
        if ! mount /samba/"${smbvolumefilename}" /new_root; then
            echo "Failed to mount /new_root!"
            launch_interactive_shell
        fi
    else
        if ! mount -o "${newrootmountopts}" /samba/"${smbvolumefilename}" /new_root; then
            echo "Failed to mount /new_root!"
            launch_interactive_shell
        fi
    fi
}

copy_resolvconf() {
    if [ -L /new_root/etc/resolv.conf ]; then
        rm -f /new_root/etc/resolv.conf
    fi
    cp -f -a /etc/resolv.conf /new_root/etc/resolv.conf || \
    cat /etc/resolv.conf > /new_root/etc/resolv.conf

    if [ -e /new_root/etc/resolv.conf.tail ]; then
        rm -f /new_root/etc/resolv.conf.tail
    fi
    cp -f -a /etc/resolv.conf.tail /new_root/etc/resolv.conf.tail || \
    cat /etc/resolv.conf.tail > /new_root/etc/resolv.conf.tail
}

copy_dhcpcd_data() {
    local filecopy

    if [ -f /new_root/etc/dhcpcd.conf ]; then
        rm -f /new_root/etc/dhcpcd.conf
    fi
    cp -f -a /etc/dhcpcd.conf /new_root/etc/dhcpcd.conf || \
    cat /etc/dhcpcd.conf > /new_root/etc/dhcpcd.conf

    if [ -d /new_root/var/lib/dhcpcd ]; then
        :
    else
        if [ -e /new_root/var/lib/dhcpcd ]; then
            rm -r -f /new_root/var/lib/dhcpcd
        fi
        install -d -m 750 /new_root/var/lib/dhcpcd
    fi

    rm -r -f /new_root/var/lib/dhcpcd/* 2>/dev/null
    for filecopy in /var/lib/dhcpcd/*; do
        [ "$filecopy" == "/var/lib/dhcpcd/*" ] && return 0
        cp -a "$filecopy" /new_root"$filecopy"
    done
}

swapon_samba() {
    local devloop

    if [ "$smbswapfilename" == "@n@" ]; then
        return 0
    else
        plymouth_show_msg "Connecting swap file"
        case "$smbswapfilename" in
            "/"*) smbswapfilename="${smbswapfilename#/}" ;;
        esac
        if ! devloop="$(losetup --show --find -- /samba/"${smbswapfilename}")"; then
            echo "Failed to setup loop on /samba/${smbswapfilename}!"
            launch_interactive_shell
        fi

        sysctl -q -w vm.swappiness=2 \
                     vm.dirty_writeback_centisecs=1000 \
                     vm.dirty_background_ratio=3 \
                     vm.dirty_ratio=40

        if ! swapon "$devloop"; then
            echo "Failed to swapon $devloop!"
            launch_interactive_shell
        fi
        #if ! swapon /samba/"${smbswapfilename}"; then
        #    echo "Failed to swapon /samba/$smbswapfilename!"
        #    launch_interactive_shell
        #fi
    fi
}

export PATH='/usr/local/sbin:/usr/local/bin:/usr/bin'

udevd_running=0
mount_handler=default_mount_handler
init=/sbin/init
rd_logmask=0

. /init_functions

unset -f launch_interactive_shell
# shellcheck disable=SC2120
launch_interactive_shell() {
    plymouth_pause

    export PS1='[rootfs \W]\$ '

    # explicitly redirect to /dev/console in case we're logging. note that
    # anything done in the rescue shell will NOT be logged.
    {
        [ "$1" = "--exec" ] && exec bash -i
        bash -i
    } 0</dev/console 1>/dev/console 2>/dev/console

    plymouth_continue
}

mount_setup

# parse the kernel command line
parse_cmdline </proc/cmdline

###
sleep 1
clear || echo -ne '\e[H\e[J'
echo -ne '\e[3J'
###

# setup logging as early as possible
rdlogger_start

# busybox ash supports string replacements
# shellcheck disable=SC3060
# assigned by parse_cmdline
# shellcheck disable=SC2154
for d in ${disablehooks//,/ }; do
    [ -e "/hooks/$d" ] && chmod 644 "/hooks/$d"
done

# shellcheck disable=SC1091
. /config

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_earlyhook' 'early hook' $EARLYHOOKS

if [ -n "$earlymodules$MODULES" ]; then
    # busybox ash supports string replacements
    # shellcheck disable=SC3060,SC2086
    modprobe -qab ${earlymodules//,/ } $MODULES
fi

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_hook' 'hook' $HOOKS

# honor the old behavior of break=y as a synonym for break=premount
# assigned by parse_cmdline
# shellcheck disable=SC2154
if [ "${break}" = "y" ] || [ "${break}" = "premount" ]; then
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    echo ":: Pre-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

# In case we using rdlogger
#exec 0</dev/console 1>/dev/console 2>/dev/console

set -o emacs

echo ''
for i in 1 2 3; do
    msg -ne '\rHello! \e[1;32m|\e[0m'
    sleep 0.1
    msg -ne '\rHello! \e[1;32m/\e[0m'
    sleep 0.1
    msg -ne '\rHello! \e[1;32m-\e[0m'
    sleep 0.1
    msg -ne '\rHello! \e[1;32m\\\e[0m'
    sleep 0.1
done
msg -ne '\r         '
msg -ne '\r'
[ -f /banner_kexec ] && cat /banner_kexec
###
display_version

plymouth_show_msg "Processing kernel command line"
asshole_parse </proc/cmdline

plymouth_show_msg "Bringing UP 'lo' network interface"
bring_lo_up

plymouth_show_msg "Obtaining IP address via DHCP"
get_dhcp

plymouth_show_msg "Changing the process priority of dhcpcd"
renice_dhcpcd

plymouth_show_msg "Mounting SAMBA"
mount_samba

plymouth_show_msg "Checking the root file system for errors"
fsck_in_samba

plymouth_show_msg "Mounting root file system"
mount_newroot

plymouth_show_msg "Copying resolv.conf"
copy_resolvconf

plymouth_show_msg "Copying dhcpcd data"
copy_dhcpcd_data

swapon_samba

plymouth_show_msg "Booting..."

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_latehook' 'late hook' $LATEHOOKS

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_cleanuphook' 'cleanup hook' $CLEANUPHOOKS

if [ "$(stat -c %D /)" = "$(stat -c %D /new_root)" ]; then
    # Nothing got mounted on /new_root. This is the end, we don't know what to do anymore
    # We fall back into a shell, but the shell has now PID 1
    # This way, manual recovery is still possible.
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    err "Failed to mount the real root device."
    echo "Bailing out, you are on your own. Good luck."
    echo
    launch_interactive_shell --exec
elif [ ! -x "/new_root${init}" ]; then
    # Successfully mounted /new_root, but ${init} is missing
    # The same logic as above applies
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    err "Root device mounted successfully, but ${init} does not exist."
    echo "Bailing out, you are on your own. Good luck."
    echo
    launch_interactive_shell --exec
fi

if [ "${break}" = "postmount" ]; then
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    echo ":: Post-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

# this should always be the last thing we do before the switch_root.
rdlogger_stop

plymouth_show_msg ""

exec env -i \
    "TERM=$TERM" \
    /usr/bin/switch_root /new_root "$init" "$@"

# vim: set ft=sh ts=4 sw=4 et:
