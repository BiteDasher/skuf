#!/usr/bin/bash

skuf_version="3.3+37.2"

smbaddr='###'
smbport='###'
smbversion='###'
smbdomain='###'
smbusername='###'
smbpassword='###'
smbvolumepath='###'
smbvolumefilename='###'
smbswapfilename='###'
smbmountopts='###'
newrootmountopts='###'
newrootfsck='###'
smbmode="ro"

kernelopts='###'

kernelpath='###'
initramfspath='###'

sambaopts=

display_version() {
    local letter1="$(( RANDOM % 7 ))"
    local letter2="$(( RANDOM % 7 ))"
    local letter3="$(( RANDOM % 7 ))"
    local letter4="$(( RANDOM % 7 ))"

    echo -e "\e[1;3${letter1}mS\e[0m\e[1;3${letter2}mK\e[0m\e[1;3${letter3}mU\e[0m\e[1;3${letter4}mF\e[0m v${skuf_version}"
}

___() {
    if [ "$1" == "_" ]; then
        echo -e '\e[0m'
    else
        echo -ne '\e[0m'
    fi
}

check_smbaddr() {
    if [ "$smbaddr" == '###' ]; then
        return 1
    fi
    if [ -z "$smbaddr" ]; then
        echo -e "  \e[1;31m! SAMBA server address missing\e[0m"
        return 1
    fi

    return 0
}

check_smbport() {
    if [ "$smbport" == '###' ]; then
        return 1
    fi
    if [ -z "$smbport" ]; then
        smbport="@n@"
        return 0
    fi
    if [ -n "$smbport" ] && [ -z "${smbport//[0-9]/}" ]; then
        return 0
    else
        echo -e "  \e[1;31m! This does not look like SAMBA port\e[0m"
        return 1
    fi
}

check_smbversion() {
    if [ "$smbversion" == '###' ]; then
        return 1
    fi
    if [ -z "$smbversion" ]; then
        smbversion="@n@"
        return 0
    fi
}

check_smbdomain() {
    if [ "$smbdomain" == '###' ]; then
        return 1
    fi
    if [ -z "$smbdomain" ]; then
        smbdomain="@n@"
        return 0
    fi
}

check_smbusername() {
    if [ "$smbusername" == '###' ]; then
        return 1
    fi
    if [ -z "$smbusername" ]; then
        echo -e "  \e[1;31m! Login missing\e[0m"
        return 1
    fi

    return 0
}

read_smbpassword() {
    local password charcount prompt char

    echo -n "Password:               $ylw"

    charcount=0
    while IFS= read -p "$prompt" -r -s -n 1 char; do
        if [[ $char == $'\0' ]] ; then
            break
        fi
        if [[ $char == $'\177' ]] ; then
            if [ $charcount -gt 0 ] ; then
                charcount=$((charcount-1))
                prompt=$'\b \b'
                password="${password%?}"
            else
                prompt=''
            fi
        else
            charcount=$((charcount+1))
            prompt='*'
            password+="$char"
        fi
    done

    smbpassword="$password"
}

check_smbpassword() {
    if [ "$smbpassword" == '###' ]; then
        return 1
    fi
    if [ -z "$smbpassword" ]; then
        echo -e "  \e[1;31m! Password missing\e[0m"
        return 1
    fi

    return 0
}

check_smbvolumepath() {
    if [ "$smbvolumepath" == '###' ]; then
        return 1
    fi
    if [ -z "$smbvolumepath" ]; then
        smbvolumepath="@n@"
        return 0
    fi
}

check_smbvolumefilename() {
    if [ "$smbvolumefilename" == '###' ]; then
        return 1
    fi
    if [ -z "$smbvolumefilename" ]; then
        echo -e "  \e[1;31m! Volume file name missing\e[0m"
        return 1
    fi
    case "$smbvolumefilename" in
        *"/")
            echo -e "  \e[1;31m! Volume file cannot be a folder\e[0m"
            return 1
        ;;
    esac

    return 0
}

check_smbswapfilename() {
    if [ "$smbswapfilename" == '###' ]; then
        return 1
    fi
    if [ -z "$smbswapfilename" ]; then
        smbswapfilename="@n@"
        return 0
    fi
    case "$smbswapfilename" in
        *"/")
            echo -e "  \e[1;31m! swap-file cannot be a folder\e[0m"
            return 1
        ;;
    esac

    return 0
}

check_smbmountopts() {
    if [ "$smbmountopts" == '###' ]; then
        return 1
    fi
    if [ -z "$smbmountopts" ]; then
        smbmountopts="@n@"
        return 0
    fi
}

check_newrootmountopts() {
    if [ "$newrootmountopts" == '###' ]; then
        return 1
    fi
    if [ -z "$newrootmountopts" ]; then
        newrootmountopts="@n@"
        return 0
    fi
}

check_newrootfsck() {
    if [ "$newrootfsck" == '###' ]; then
        return 1
    fi
    case "$newrootfsck" in
        Y|y|Yes|yes|Д|д|Да|да)
            newrootfsck="Yes"
            return 0
        ;;
        N|n|No|no|Н|н|Нет|нет)
            newrootfsck="No"
            return 0
        ;;
        "")
            newrootfsck="@n@"
            return 0
        ;;
        *)
            echo -e "  \e[1;31m! Unknown answer variant\e[0m"
            return 1
        ;;
    esac
}

check_kernelopts() {
    if [ "$kernelopts" == '###' ]; then
        return 1
    fi
    if [ -z "$kernelopts" ]; then
        kernelopts="@n@"
        return 0
    fi
}

check_kernelpath() {
    if [ "$kernelpath" == '###' ]; then
        return 1
    fi
    if [ -z "$kernelpath" ]; then
        echo -e "  \e[1;31m! Path to kernel missing\e[0m"
        return 1
    fi
    case "$kernelpath" in
        "/"*)
            return 0
        ;;
        *)
            echo -e "  \e[1;31m! You should type FULL path to kernel\e[0m"
            return 1
        ;;
    esac
}

check_initramfspath() {
    if [ "$initramfspath" == '###' ]; then
        return 1
    fi
    if [ -z "$initramfspath" ]; then
        echo -e "  \e[1;31m! Path to initramfs missing\e[0m"
        return 1
    fi
    case "$initramfspath" in
        "/"*)
            return 0
        ;;
        *)
            echo -e "  \e[1;31m! You should type FULL path to initramfs\e[0m"
            return 1
        ;;
    esac
}

user_read() {
    local ylw="$(echo -e '\e[1;33m')"
    local blu="$(echo -e '\e[1;36m')"

    echo -e "To change the keyboard layout, press \e[1mAlt+Shift\e[0m (ru)" # SKUF_RU #

    while ! check_smbaddr; do
        read -e -p "SAMBA server address:   $ylw" \
                # SAMBA_ADDRESS #
        ___
    done
    while ! check_smbport; do
        read -e -p "SAMBA server port:      $ylw" \
                # SAMBA_PORT #
        ___
    done
    while ! check_smbversion; do
        read -e -p "SAMBA protocol version: $ylw" \
                # SAMBA_VERSION #
        ___
    done
    while ! check_smbdomain; do
        read -e -p "SAMBA server domain:    $ylw" \
                # SAMBA_DOMAIN #
        ___
    done
    while ! check_smbusername; do
        read -e -p "Login:                  $ylw" \
                smbusername
        ___
    done
    while ! check_smbpassword; do
                read_smbpassword
        ___ _
    done
    while ! check_smbvolumepath; do
        read -e -p "Path to your folder:    $ylw" \
                # VOLUME_PATH #
        ___
    done
    while ! check_smbvolumefilename; do
        read -e -p "Volume file name:       $ylw" \
                # VOLUME_FILENAME #
        ___
    done
    while ! check_smbswapfilename; do
        read -e -p "swap-file name:         $ylw" \
                # SWAP_FILENAME #
        ___
    done
    while ! check_smbmountopts; do
        read -e -p "Extra SAMBA mount options:  $ylw" \
                # SAMBA_EXTRA_MOUNT_OPTS #
        ___
    done
    while ! check_newrootmountopts; do
        read -e -p "Extra volume mount options: $ylw" \
                # VOLUME_EXTRA_MOUNT_OPTS #
        ___
    done
    while ! check_newrootfsck; do
        read -e -p "Check volume FS? [Yes/no]:  $ylw" \
                # CHECK_FS #
        ___
    done
    while ! check_kernelopts; do
        read -e -p "Extra kernel parameters:    $ylw" \
                # EXTRA_KERNEL_OPTS #
        ___
    done
    echo '....................................'
    while ! check_kernelpath; do
        read -e -p "Path to new kernel:         $blu" \
                # PATH_TO_NEW_KERNEL #
        ___
    done
    while ! check_initramfspath; do
        read -e -p "Path to new initramfs:      $blu" \
                # PATH_TO_NEW_INITRAMFS #
        ___
    done

    ___ _
}

setup_sambaopts() {
    local sambaoptsx

    echo "[] Building and encrypting /proc/cmdline"

    sambaoptsx="$smbaddr,,,$smbport,,,$smbversion,,,$smbdomain,,,$smbusername,,,$smbpassword,,,$smbvolumepath,,,$smbvolumefilename,,,$smbswapfilename,,,$smbmountopts,,,$newrootmountopts,,,$newrootfsck"
    # SKUF_OPENSSL_ENC #
    sambaoptsx="$(echo "$sambaoptsx" | openssl enc -e -aes-256-cbc -salt -iter 1234 -base64 -A -k '12345678' -in - -out -)" # SKUF_OPENSSL_ENC_RM #
    sambaoptsx="${sambaoptsx//=/%}"
    sambaoptsx="${sambaoptsx:10}"

    # SKUF_ENC_TUNE #

    sambaopts="fuckmyass=${sambaoptsx}:"
}

setup_kernelopts() {
    if [ "$kernelopts" == "@n@" ]; then
        kernelopts=
    else
        kernelopts="$kernelopts "
    fi
}

bring_lo_up() {
    echo "[] Bringing UP 'lo' network interface"
    ip link set lo up
}

shutdown_interfaces() {
    echo "[] Bringing DOWN network interfaces"
    ip addr flush dev lo
    ip link set lo down
    ip addr flush dev "$to_dhcp"
    ip link set "$to_dhcp" down
}

get_dhcp() {
    local x="0" c="0"

    for i in /sys/class/net/*; do
	    interface="${i##*/}"

        case "$interface" in
            *eth*) : ;;
            *enp*) : ;;
            *ens*) : ;;
            *)     continue ;;
        esac

        ethernets="$ethernets $interface"
        ethernetone="$interface"
	    x=$(( x + 1 ))
	done

    if [ $x -gt 1 ]; then
        echo "There is more than one network interface. Select one from the list:"

        for i in $ethernets; do
            c=$(( c + 1 ))
            eval 'ether'$c'='$i''
            echo "$c. $i"
        done

        while case "$choice_dhcp" in
                ''|*[!0-9]*) true  ;;
                0*)          true  ;;
                *)           false ;;
              esac; do
            read -p "> " choice_dhcp
        done
        if [ $choice_dhcp -gt $c ]; then
            choice_dhcp=$c
        fi
        eval 'to_dhcp=$ether'$choice_dhcp''
    else
        to_dhcp="$ethernetone"
    fi

    echo "[] Obtaining IP-address via DHCP"

    if ! dhcpcd "$to_dhcp"; then
        echo "Failed to acquire DHCP address."
        launch_interactive_shell
    fi

    echo "-> Sleeping 5 seconds..."
    sleep 5
}

mount_samba() {
    finalusername="username=$smbusername,"
    #finalpassword="password=$smbpassword,"
    [ "$smbdomain" == "@n@" ] || finaldomain="domain=$smbdomain,"
    [ "$smbport" == "@n@" ] || finalport="port=$smbport,"
    [ "$smbmountopts" == "@n@" ] || finalmountopts="$smbmountopts,"
    smbvolumepath="${smbvolumepath/@u@/${smbusername/@*/}}"
    smbvolumepath="${smbvolumepath/@fu@/${smbusername}}"
    case "$smbvolumepath" in
        "/") : ;;
        "/"*"/") : ;;
        "/"*) smbvolumepath="${smbvolumepath}/" ;;
        *"/") smbvolumepath="/${smbvolumepath}" ;;
        "@n@") smbvolumepath="/" ;;
        *) smbvolumepath="/${smbvolumepath}/" ;;
    esac
    smbvolumefilename="${smbvolumefilename/@u@/${smbusername/@*/}}"
    smbvolumefilename="${smbvolumefilename/@fu@/${smbusername}}"
    case "$smbvolumefilename" in
        "/"*) smbvolumefilename="${smbvolumefilename#/}" ;;
    esac
    [ "$smbversion" == "@n@" ] || finalversion="vers=$smbversion,"

    echo "[] Mounting SAMBA"

    if ! PASSWD="$smbpassword" mount -t cifs -o "${finalusername}${finaldomain}${finalport}${finalmountopts}${finalversion}${smbmode}" "//${smbaddr}${smbvolumepath}" /samba; then
        echo "Failed to mount SAMBA share!"
        echo "PASSWD=$smbpassword mount -t cifs -o ${finalusername}${finaldomain}${finalport}${finalmountopts}${finalversion}${smbmode} //${smbaddr}${smbvolumepath} /samba"
        launch_interactive_shell
    fi
}

fsck_in_samba() {
    # We shouldn't do it in R/O mode...
    case "$newrootfsck" in
    Yes|yes|Y|y)
    if [ "$(blkid -o value -s TYPE /samba/"${smbvolumefilename}")" == "btrfs" ]; then
        btrfsck /samba/"${smbvolumefilename}" || launch_interactive_shell
    else
        fsck -T -a -C /samba/"${smbvolumefilename}"
        fsckreturn="$?"

        if [ -n "$fsckreturn" ] && [ "$fsckreturn" -ne 255 ]; then

        if bitfield_has_bit "$fsckreturn" 4; then
            echo "fsck failed..."
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 2; then
            echo "fsck tells you need to reboot"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 8; then
            echo "Something went wrong..."
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 16; then
            echo "Syntax error in fsck"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 32; then
            echo "Somehow you canceled fsck"
            launch_interactive_shell
        elif bitfield_has_bit "$fsckreturn" 128; then
            echo "FATAL ERROR xD"
            launch_interactive_shell
        fi

        fi
    fi
    ;;
    No|no|N|n)
        :
    ;;
    "@n@")
        :
    ;;
    esac
}

mount_newroot() {
    local newrootmountoptsx

    echo "[] Mounting volume"

    if [ "$newrootmountopts" == "@n@" ]; then
        newrootmountoptsx=
    else
        newrootmountoptsx=",$newrootmountopts"
    fi

    if [ "$(blkid -o value -s TYPE /samba/"${smbvolumefilename}")" == "ext4" ]; then
        if ! mount -o "ro,noload${newrootmountoptsx}" /samba/"${smbvolumefilename}" /new_root; then
            echo "Failed to mount /new_root!"
            launch_interactive_shell
        fi
    else
        if ! mount -o "ro${newrootmountoptsx}" /samba/"${smbvolumefilename}" /new_root; then
            echo "Failed to mount /new_root!"
            launch_interactive_shell
        fi
    fi
}

unpack_switch() {
    echo "[] Unpacking environment for switch_root"

    mount -t tmpfs switch /switch -o size=5M

    tar -x -f /rootfs.tar -C /switch
}

prepare_kexec() {
    echo "[] Preparing kexec"
    echo "[] Loading kernel and initramfs into RAM"

    /switch/bin/kexec -l "/new_root${kernelpath}" --initrd="/new_root${initramfspath}" --command-line="${kernelopts}${sambaopts}" --console-vga --reset-vga
}

prepare_switch() {
    echo "[] Preparing environment for switch_root"

    ln -sfT /proc/self/mounts /switch/etc/mtab

    echo "[] Editing kexec script"

    cat <<'SWITCHEOF' >> /switch/init
export PATH=/bin

kill -SIGTERM -1
sleep 1
kill -SIGKILL -1
sleep 1

exec 0</dev/console
exec 1>/dev/console
exec 2>&1

sleep 1

_soterm="$(stty size)"

umount -a
umount -a

_ud="${_soterm%% *}"
_lr="${_soterm##* }"
_udc="$(( ( _ud - 8 ) / 2 ))"
_lrc="$(( ( _lr - 53 ) / 2 ))"

funmsg1=" _    _                                            _ "
funmsg2="| |  | |                                          | |"
funmsg3="| |__| | ___ _ __ ___  __      _____    __ _  ___ | |"
funmsg4="|  __  |/ _ \ '__/ _ \ \ \ /\ / / _ \  / _\` |/ _ \| |"
funmsg5="| |  | |  __/ | |  __/  \ V  V /  __/ | (_| | (_) |_|"
funmsg6="|_|  |_|\___|_|  \___|   \_/\_/ \___|  \__, |\___/(_)"
funmsg7="                                        __/ |        "
funmsg8="                                       |___/         "

clear

xxx=0
while [ "$xxx" != "$_udc" ]; do
    xxx="$(( xxx + 1 ))"
    echo ""
done

yyy=0
zzz=0
while [ "$yyy" != 8 ]; do
    yyy="$(( yyy + 1 ))"
    zzz=0
    while [ "$zzz" != "$_lrc" ]; do
        zzz="$(( zzz + 1 ))"
        echo -n " "
    done
	eval 'echo "$funmsg'$yyy'"'
done

ccc=0
while [ "$ccc" != "$_udc" ]; do
    ccc="$(( ccc + 1 ))"
    echo ""
done

sleep 1

exec kexec -e
SWITCHEOF
}

unmount_stuff() {
    echo "[] Unmounting volume and SAMBA"
    umount /new_root
    sleep 1
    umount /samba
    sleep 1
}

kill_dhcp_client() {
    echo "[] Attempt to kill dhcpcd"
    killall -SIGTERM dhcpcd 2>/dev/null
    sleep 2
    killall -SIGKILL dhcpcd 2>/dev/null
}

perform_kexec() {
    echo "[!] Executing new kernel"

    exec env -i TERM="$TERM" SHELL=/bin/ash switch_root \
         /switch /init
}

export PATH='/usr/local/sbin:/usr/local/bin:/usr/bin'

udevd_running=0
mount_handler=default_mount_handler
init=/sbin/init
rd_logmask=0

. /init_functions

unset -f launch_interactive_shell
# shellcheck disable=SC2120
launch_interactive_shell() {
    export PS1='[rootfs \W]\$ '

    # explicitly redirect to /dev/console in case we're logging. note that
    # anything done in the rescue shell will NOT be logged.
    {
        [ "$1" = "--exec" ] && exec bash -i
        bash -i
    } 0</dev/console 1>/dev/console 2>/dev/console
}

mount_setup

# parse the kernel command line
parse_cmdline </proc/cmdline

# setup logging as early as possible
rdlogger_start

# busybox ash supports string replacements
# shellcheck disable=SC3060
# assigned by parse_cmdline
# shellcheck disable=SC2154
for d in ${disablehooks//,/ }; do
    [ -e "/hooks/$d" ] && chmod 644 "/hooks/$d"
done

# shellcheck disable=SC1091
. /config

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_earlyhook' 'early hook' $EARLYHOOKS

if [ -n "$earlymodules$MODULES" ]; then
    # busybox ash supports string replacements
    # shellcheck disable=SC3060,SC2086
    modprobe -qab ${earlymodules//,/ } $MODULES
fi

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_hook' 'hook' $HOOKS

# honor the old behavior of break=y as a synonym for break=premount
# assigned by parse_cmdline
# shellcheck disable=SC2154
if [ "${break}" = "y" ] || [ "${break}" = "premount" ]; then
    # shellcheck disable=SC2086
    run_hookfunctions 'run_emergencyhook' 'emergency hook' $EMERGENCYHOOKS
    echo ":: Pre-mount break requested, type 'exit' to resume operation"
    launch_interactive_shell
fi

exec 0</dev/console 1>/dev/console 2>/dev/console

set -o emacs

echo ''
for i in 1 2 3 4 5; do
	echo -ne '\rHello! \e[1;32m|\e[0m'
	sleep 0.1
	echo -ne '\rHello! \e[1;32m/\e[0m'
	sleep 0.1
	echo -ne '\rHello! \e[1;32m-\e[0m'
	sleep 0.1
	echo -ne '\rHello! \e[1;32m\\\e[0m'
	sleep 0.1
done
echo -ne '\r        '
echo ''
[ -f /banner_usb ] && cat /banner_usb
###
display_version

user_read

bring_lo_up

get_dhcp

mount_samba

#fsck_in_samba

mount_newroot

setup_sambaopts

setup_kernelopts

unpack_switch

prepare_kexec

prepare_switch

unmount_stuff

kill_dhcp_client

shutdown_interfaces

# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_latehook' 'late hook' $LATEHOOKS

echo "[] Finishing some work"
# We rely on word splitting
# shellcheck disable=SC2086
run_hookfunctions 'run_cleanuphook' 'cleanup hook' $CLEANUPHOOKS

# this should always be the last thing we do before the switch_root.
rdlogger_stop

perform_kexec

# vim: set ft=sh ts=4 sw=4 et:
